package main

import (
	_ "embed"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	cdx "github.com/CycloneDX/cyclonedx-go"
	"github.com/spf13/cobra"
)

var (
	outputPath  string
	projectType string
	verbose     bool
)

func main() {
	var rootCmd = &cobra.Command{
		Use:   "rudor",
		Short: "Simple SBOM generator using embedded cdxgen",
	}

	var generateCmd = &cobra.Command{
		Use:   "generate [path]",
		Short: "Generate SBOM for a project",
		Args:  cobra.MaximumNArgs(1),
		Run:   runGenerate,
	}

	generateCmd.Flags().StringVarP(&outputPath, "output", "o", "bom.json", "Output file path")
	generateCmd.Flags().StringVarP(&projectType, "type", "t", "", "Project type (auto-detected if not specified)")
	generateCmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Enable verbose output")

	rootCmd.AddCommand(generateCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func runGenerate(cmd *cobra.Command, args []string) {
	projectPath := "."
	if len(args) > 0 {
		projectPath = args[0]
	}

	if err := generateSBOM(projectPath, outputPath, projectType, verbose); err != nil {
		fmt.Printf("‚ùå Error: %v\n", err)
		os.Exit(1)
	}
}

func generateSBOM(projectPath, output, projType string, verbose bool) error {
	var tempBinaryPath string
	defer func() {
		if tempBinaryPath != "" && fileExists(tempBinaryPath) {
			if err := os.Remove(tempBinaryPath); err != nil && verbose {
				fmt.Printf("‚ö†Ô∏è Warning: Could not delete temporary file %s: %v\n", tempBinaryPath, err)
			}
		}
	}()

	// Convert to absolute path
	absolutePath, err := filepath.Abs(projectPath)
	if err != nil {
		return fmt.Errorf("failed to get absolute path: %w", err)
	}

	// Check if path exists
	if !fileExists(absolutePath) && !dirExists(absolutePath) {
		return fmt.Errorf("path does not exist: %s", absolutePath)
	}

	fmt.Printf("üîç Generating SBOM for: %s\n", absolutePath)

	// Extract embedded binary to temporary location
	tempBinaryPath, err = extractEmbeddedBinary(verbose)
	if err != nil {
		return fmt.Errorf("failed to extract embedded binary: %w", err)
	}

	// Create temporary file for cdxgen output
	tempBOMFile, err := os.CreateTemp("", "rudor-bom-*.json")
	if err != nil {
		return fmt.Errorf("failed to create temporary BOM file: %w", err)
	}
	tempBOMPath := tempBOMFile.Name()
	tempBOMFile.Close()

	// Ensure cleanup of temporary BOM file
	defer func() {
		if err := os.Remove(tempBOMPath); err != nil && verbose {
			fmt.Printf("‚ö†Ô∏è Warning: Could not delete temporary BOM file %s: %v\n", tempBOMPath, err)
		}
	}()

	// Build cdxgen arguments using the temporary file
	args := []string{"-o", tempBOMPath}

	// Add project type if specified
	if projType != "" {
		args = append(args, "-t", projType)
	}

	// Add the path to scan at the end
	args = append(args, absolutePath)

	if verbose {
		fmt.Printf("Running: %s %s\n", tempBinaryPath, strings.Join(args, " "))
	}

	if verbose {
		fmt.Printf("üîß Using temporary BOM file: %s\n", tempBOMPath)
	}

	// Execute cdxgen
	cmd := exec.Command(tempBinaryPath, args...)

	if verbose {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	}

	if err := cmd.Run(); err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			return fmt.Errorf("cdxgen failed with exit code: %d", exitErr.ExitCode())
		}
		return fmt.Errorf("failed to execute cdxgen: %w", err)
	}

	// Check if temporary BOM file was created
	if !fileExists(tempBOMPath) {
		return fmt.Errorf("SBOM file was not generated by cdxgen")
	}

	// Enhance the BOM with Rudor metadata
	if err := enhanceBOM(tempBOMPath, output, verbose); err != nil {
		return fmt.Errorf("failed to enhance BOM: %w", err)
	}

	absoluteOutput, err := filepath.Abs(output)
	if err != nil {
		absoluteOutput = output
	}

	fmt.Printf("‚úÖ SBOM generated successfully: %s\n", absoluteOutput)
	return nil
}

func extractEmbeddedBinary(verbose bool) (string, error) {
	binaryData, binaryName, err := getEmbeddedBinary()
	if err != nil {
		return "", err
	}

	if verbose {
		fmt.Printf("üîß Extracting embedded binary: %s\n", binaryName)
	}

	// Create temporary file
	tempFile, err := os.CreateTemp("", "cdxgen-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temporary file: %w", err)
	}
	tempPath := tempFile.Name()
	tempFile.Close()

	// On Windows, add .exe extension
	if runtime.GOOS == "windows" {
		os.Remove(tempPath)
		tempPath = tempPath + ".exe"
	}

	// Write embedded binary to temporary file
	if err := os.WriteFile(tempPath, binaryData, 0755); err != nil {
		return "", fmt.Errorf("failed to write binary to temporary file: %w", err)
	}

	// Make executable on Unix-like systems
	if runtime.GOOS != "windows" {
		if err := os.Chmod(tempPath, 0755); err != nil {
			return "", fmt.Errorf("failed to make binary executable: %w", err)
		}
	}

	if verbose {
		fmt.Printf("‚úÖ Binary extracted to: %s\n", tempPath)
	}

	return tempPath, nil
}

func getEmbeddedBinary() ([]byte, string, error) {
	return embeddedBinary, binaryName, nil
}

func fileExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && !info.IsDir()
}

func dirExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && info.IsDir()
}

// enhanceBOM reads a BOM from inputPath, enhances it with Rudor metadata, and writes it to outputPath
func enhanceBOM(inputPath, outputPath string, verbose bool) error {
	if verbose {
		fmt.Println("üîß Enhancing BOM with Rudor metadata...")
	}

	// Read the existing BOM file
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return fmt.Errorf("failed to open SBOM file: %w", err)
	}
	defer inputFile.Close()

	// Decode the BOM
	bom := new(cdx.BOM)
	decoder := cdx.NewBOMDecoder(inputFile, cdx.BOMFileFormatJSON)
	if err := decoder.Decode(bom); err != nil {
		return fmt.Errorf("failed to decode SBOM: %w", err)
	}

	// Initialize metadata if it doesn't exist
	if bom.Metadata == nil {
		bom.Metadata = &cdx.Metadata{}
	}

	// Initialize tools if it doesn't exist
	if bom.Metadata.Tools == nil {
		bom.Metadata.Tools = &cdx.ToolsChoice{}
	}

	// Create Rudor component with dynamic information
	appName := getBinaryName()
	orgName := "Iron Kite"
	email := "info@ironkite.com"

	rudorComponent := &cdx.Component{
		Type:      cdx.ComponentTypeApplication,
		Name:      appName,
		Version:   getVersion(),
		Publisher: orgName,
		Authors: &[]cdx.OrganizationalContact{
			{
				Name:  orgName,
				Email: email,
			},
		},
	}

	// Add rudor component to BOM metadata tools
	if bom.Metadata.Tools.Components == nil {
		bom.Metadata.Tools.Components = &[]cdx.Component{*rudorComponent}
	} else {
		// Check if our tool already exists and update it, or add it
		found := false
		for i, component := range *bom.Metadata.Tools.Components {
			if component.Name == appName {
				(*bom.Metadata.Tools.Components)[i] = *rudorComponent
				found = true
				break
			}
		}
		if !found {
			*bom.Metadata.Tools.Components = append(*bom.Metadata.Tools.Components, *rudorComponent)
		}
	}

	// Create output file
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outputFile.Close()

	// Encode the enhanced BOM
	encoder := cdx.NewBOMEncoder(outputFile, cdx.BOMFileFormatJSON)
	encoder.SetPretty(true)

	if err := encoder.Encode(bom); err != nil {
		return fmt.Errorf("failed to encode enhanced SBOM: %w", err)
	}

	if verbose {
		fmt.Printf("‚úÖ BOM enhanced with %s metadata\n", appName)
	}

	return nil
}

// getBinaryName extracts the binary name from os.Args[0]
func getBinaryName() string {
	binaryPath := os.Args[0]
	binaryName := filepath.Base(binaryPath)

	// Remove .exe extension on Windows
	if runtime.GOOS == "windows" {
		if ext := filepath.Ext(binaryName); ext == ".exe" {
			binaryName = strings.TrimSuffix(binaryName, ext)
		}
	}

	return binaryName
}

// getVersion returns the version, defaulting to "1.0.0" if not set
func getVersion() string {
	return "1.0.0" // You can make this dynamic with build-time variables
}
